#include<iostream>
using namespace std;




//// 程序开始运行后划分的区域：（栈区、堆区）
// 这里是.exe文件开始运行后划分的区域






//// 栈区：
// 【栈区内的数据由编译器自动分配和释放，具有局部性】，栈区存放函数的参数、局部变量等
// 注意：不要访问生命周期已经结束(已经被系统释放)的局部变量的地址
//		 原因：【栈区的数据在出了作用域后会被自动释放】
//
//
// 
//// 栈区数据的作用域问题：
// 
// 问：为什么局部变量只能在其作用域内使用？
// 答：局部变量存放在栈区，栈区会为变量自动分配和释放空间，出了作用域后空间就被释放
//
// 由于栈具有自动分配释放数据空间的特性，导致【只有栈中的数据有明确的作用域限制】
// （全局区变量不具有作用域；堆区变量在手动释放前没有作用域限制）



//// 不要返回(访问)已被释放的局部变量的地址：
//int* func()
//{
//	int a = 10;// 局部变量，存放在栈区，栈区数据在函数执行完后自动释放
//	return &a;// 返回函数中创建的局部变量
//}
//
//int main()
//{
//	int* p = func();
//
//	cout << *p << endl;// 10（第一次可以打印正确的数字，是因为编译器为了防止误操作故意保留一次）
//	cout << *p << endl;// 1464830248（第二次数据就不再保留）
//
//	return 0;
//}








//// 堆区：
// 【由程序员分配和释放。若不手动释放，程序结束时由操作系统回收】
// 
// 
// 
//// 堆区数据的作用域问题： 
// 
// 与栈区不同的是：【堆区数据在手动释放前没有作用域的限制】，即在任何地方都可以访问堆区数据
//（栈区数据具有明确作用域的原因是系统会自动释放；相反，由于堆区数据不会自动释放，所以手动释放前没有作用域）



//// C++中主要利用new在堆区开辟内存
//int* func()
//{
//	// 利用new关键字，在堆区开辟了一块空间存放整形10；new返回堆区空间的首地址
//	// 指针p本质是局部变量，存在栈中。而指针p中存放的是堆区的地址
//	int* p = new int(10);
//	return p;
//}
//
//int main()
//{
//	int* p = func();
//
//	cout << *p << endl;// 10
//	cout << *p << endl;// 10（堆区的数据系统不会自动释放，须手动释放）
//
//	return 0;
//}




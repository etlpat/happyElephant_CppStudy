#include<iostream>
using namespace std;
#include<string>




//// 多态的基本概念
// 多态是C++面向对象三大特征之一
//
// 多态分为两类：
// 1.静态多态：函数重载、运算符重载属于静态多态，复用函数名
// 2.动态多态：派生类、虚函数实现运行时多态（通常说的多态指动态多态）
//   
// 静态多态和动态多态的区别：
// 静态多态的函数地址早绑定 - 编译阶段分配函数地址
// 动态多态的函数地址晚绑定 - 运行阶段分配函数地址
//
//
// 
//
// 
// (1)动态多态满足条件：
//		1.存在父子继承关系
//		2.父类的函数被声明为虚函数，子类对其进行重写（子类重写的函数会默认变为虚函数）
// (2)动态多态使用：
//		父类的指针或引用，执行子类对象。
// 
// 原理：
//	父类中函数为虚函数，父类对象中会存放虚函数指针，指向虚函数表（虚函数表中存放我们自己实现的函数的函数名(指针)）
//	子类继承父类，子类对象中继承到的是该【虚函数指针】。子类对虚函数进行【重写】，【虚函数表】中，【新函数覆盖旧函数】
//	以上过程发生在运行阶段，是晚绑定，因此可以实现多态
// 
// 
// 
// 注意：1.C++中允许用父类的指针或引用执行子类对象，系统不进行强制类型转换。
//				例如，Base&类型的形参，可以接收Son类的对象s。反之报错
//       2.函数重写 != 函数重载
//				重载：函数名相同，参数列表必须不同，返回值不做要求
//				重写：返回值、函数名、参数列表必须都相同
//		 3.C++规定，一个函数被声明为虚函数后，其所有派生类中的同名函数会自动成为虚函数




//class Animal
//{
//public:
//	virtual void speak() {// 虚函数（这里必须是虚函数，下面的do_speak函数才能晚绑定，实现多态）
//		cout << "动物的叫声" << endl;
//	}
//};
//
//class Cat : public Animal
//{
//public:
//	void speak() {// 对父类虚函数进行改写（虚函数指针不变，其指向的虚函数表中，子类函数覆盖父类函数）
//		cout << "喵喵喵" << endl;
//	}
//};
//
//class Dog : public Animal
//{
//public:
//	void speak() {
//		cout << "汪汪汪" << endl;
//	}
//};
//
//
//// 多态执行speak的函数（前提是父类函数为虚函数）
//void do_speak(Animal& a) {// 类型Animal&，可传入Animal子类的对象
//	a.speak();
//}
//
//
//int main()
//{
//	Animal a;
//	Cat c;
//	Dog d;
// 
//	// 多态：同一函数传入对象不同，执行不同结果
//	do_speak(c);// 喵喵喵
//	do_speak(d);// 汪汪汪
//
//
//	cout << sizeof(a) << endl;// 4
//	cout << sizeof(c) << endl;// 4（父类函数被声明为虚函数，其子类中同名函数自动成为虚函数）
//	cout << sizeof(d) << endl;// 4
//	// 注意：大小均为4，对象中存放了一个虚函数指针。
//	//		 子类对函数改写，在虚函数指针指向的虚函数表中，新函数覆盖旧函数
//
//
//	return 0;
//}





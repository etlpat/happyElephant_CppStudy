#include<iostream>
using namespace std;
#include<string>




//// 继承中同名成员处理方式
//
// 问题：当子类与父类中出现同名成员，如何通过子类对象，访问到父类中同名的数据？
// 当子类与父类中存在同名成员时，父类中的该成员仍然存在，但被隐藏，访问时默认给出子类的数据。
// 若想访问父类的该成员，需要在变量前加上父类的作用域。
// 
// 注意：1.当父类和子类中出现同名成员时，两个成员同时在于内存中，访问时优先给出子类。（注意：不是子类成员覆盖父类，而是成员共存且父类隐藏）
//		 2.当父类和子类中出现同名成员函数，子类会隐藏掉父类中所有(运载)同名函数（想在子类中调用同名父类，必须加父类作用域）
//
//  
// 
// 父子类中同名成员访问方法：
// 1.访问子类同名成员：直接访问即可（对象.成员）
// 2.访问父类同名成员：需要加作用域（对象.父类名::成员）
//	 语法：
//		 访问同名变量：s.Base::a;	   （表示s对象中，Base(父类)作用域下的a变量）
//       访问同名函数：s.Base::func(); （表示s对象中，Base(父类)作用域下的func函数）




//class Base
//{
//public:
//	int a;
//
//	Base() :a(100) {}
//
//	void func() {
//		cout << "父类func" << endl;
//	}
//	void func(int) {
//		cout << "父类func运载" << endl;
//	}
//};
//
//
//class Son :public Base
//{
//public:
//	int a;
//
//	Son() :a(20) {}
//
//	void func() {
//		cout << "子类func" << endl;
//	}
//};
//
//
//int main()
//{
//	Son s;
//	cout << sizeof(s) << endl;// 8（父类子类中同名变量同时存在于内存中）
//
//
//	// 访问同名变量
//	cout << s.a << endl;// 20，默认给出子类数据
//	cout << s.Base::a << endl;// 100，加上作用域即可访问父类变量
//
//
//	// 访问同名函数
//	s.func();// 子类func
//	s.Base::func();// 父类func，加上作用域即可访问父类函数
//
//	//s.func(1);// 当子类父类函数同名，子类会隐藏掉父类所有运载的函数
//	s.Base::func(1);// 父类func运载
//
//
//	return 0;
//}

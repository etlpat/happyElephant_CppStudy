#include<iostream>
using namespace std;
#include<string>


// 树
//
//
// (1)基本概念
//	根结点：没有前驱的结点（一棵树只有一个根）
//	分支结点：有前驱和后继的结点
//	叶子结点：有前驱，没有后继的结点
// 
//	有序树：结点的左子树和右子树有次序，不能互换
//	无序树：结点的左右子树无效，可以互换
//	森林：森林是m棵互不相交的树的集合(m>=0)
// 
//	结点的层次(深度)：以根节点为第1层，从上往下数
//	结点的高度：从选定的叶节点，从下往上数
//	树的高度(深度)：总共多少层
// 
//	结点的度：结点拥有的子树个数
// （注意：数据结构中的树都是根树(从上到下的有向树)，结点的度默认为结点的出度，只计算子树的个数）
//	树的度：树内各结点度的最大值
//	m叉树：树的度<=m的树（如：二叉树属于三叉树）
// 
// 
// 
// (2)性质
//	1.树是一种特殊的图（树是不包含回路的图）
//	
//	2.前驱：除了根节点以外，其他一个结点有且仅有一个前驱
//	  后继：每个结点可以有0或多个后继
// 
//	3.节点数 = 边数+1
// 
//	4.m叉树，第i层最多有：m^(i-1) 个结点
//	  高度为h的m叉树，最多有：(m^h -1)/(m-1) 个结点（等比数列求和）
//	
//	5.高度为h的m叉树，最少有h个结点（m叉树要求 度<=m，1<=m成立）
//	  高度为h的度为m的树，最少有m+h-1个结点（度为m的树，度必须为m）
//	 
// 
//
// (3)二叉树
//  1.概念
//		二叉树：二叉树是度<=2的有序树
//		完全二叉树：除了最后一层外，其它层的结点都是满的，而且最后一层的结点都是靠左边排列的
//		满二叉树：每一层(包括最后一层)结点全是满的	（满二叉树属于完全二叉树）
//		二叉排序树：对于任何一结点，(左子树上的值 <  根节点的值 < 右子树的值)
//		平衡二叉树：对于任何一结点，左子树和右子树的深度之差不超过1
//
//	2.性质
//		① 非空二叉树，令度为0、1、2的结点个数分别为n0、n1、n2
//			均有：n0 = n2 + 1
// 
//		① 高度为h的满二叉树，有(2^h - 1)个结点
//		  （等比数列求和：2^0 + 2^1 + 2^2 +...+ 2^(h-1) = 2^h - 1）
// 
//		② 对完全二叉树从左到右，从上到下，以根节点为1开始标号：
//			则第i号结点的左孩子结点是2i，右孩子是2i+1
//			
//		④ 对于n个结点的完全二叉树，若当前结点为第i号结点：
//			i是叶子结点：i>[n/2]；	i不是叶子结点：i<=[n/2]
//			原理：n0=n2+1，且完全二叉树n1=0或1。因此，叶子结点数=根节点数+1，或叶子结点数=根节点数
//
//		④ 具有n个结点的完全二叉树，其高度为：[log2n]+1，[]表示向下取整



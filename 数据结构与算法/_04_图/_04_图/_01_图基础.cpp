#include<iostream>
using namespace std;
#include<string>



// 图
//
//
// (1)基本概念
//	1.【图】
//		图G：由顶点集V和边集E组成，记为 G=(V, E)；图的顶点集不能为空，边集能为空
//		n阶图：顶点个数为n的图
//		无向图：图中的边都是无向边
//		有向图：图中的边都是有向边（弧）
//		简单图：无平行边且无自环
//		多重图：有平行边或有自环
//		完全图：图中任意两顶点间都存在双向边，无向完全图边数为 n(n-1)/2
//		树：联通且不存在回路的图
//		森林：不联通且不存在回路的图
//	
//	
//	2.【度】
//		顶点的度：顶点所连接的边数（对于有向图：顶点的度=入度+出度）	
//		顶点的入度：有向图中，射入该顶点的边数
//		顶点的出度：有向图中，从该顶点射出的边数
//		握手定理：
//			1.对于无向图，图的总度数 = 2 * 总边数
//			2.对于有向图，图的总入度数 = 图的总出度数 = 总边数
//	
//	
//	3.【路径】
//		路径：两顶点间的通路
//		回路：能回到初始结点的通路（环）
//		简单路径：不经过重复顶点的路径（哈密尔顿通路）
//		简单回路：不经过重复顶点的回路（哈密尔顿回路）
//		路径长度：路径上边的数目
//		顶点到顶点的距离：两顶点间最短路径的长度（若顶点间不存在路径，则为∞）
//	
//	
//	4.【联通】
//		无向图：
//			联通：两顶点间存在通路
//			连通图：如的任意两个顶点都是联通的
//		有向图：
//			强连通图：图中任意一个结点都可以到达其它全部顶点
//			连通图：图中每个结点间至少单项可达
//			弱连通图：图中每个顶点间都有边连接，但未必都可达
//		n个顶点的无向连通图，至少有n-1条边
//		n个顶点的有向强连通图，至少有n条边
//	
//	
//	5.【子图】
//		若有：G=(V, E); G'=(V', E')
//			G'为G的子图：V'含于V，E'含于E
//			G'为G的生成子图：V'==V，E'含于E
//		  （生成子图包含原图的所有顶点）
//		连通分量：无向图的极大联通子图，称为联通分量 
//
//
//	6.【生成树】
// 		生成树：连通图的生成树，是包含图中全部顶点的一个极小连通子图
//		性质：1.若联通图有n个顶点，则其生成树有n-1条边
//			  2.生成树中不包含回路
//			  3.若在任意两顶点间加一条边，一定会形成回路；若砍掉一条边，一定会变成非连通图
//		生成森林：非连通图的生产森林，是取其每个连通分量的生成树，构成的森林
// 
// 
//	7.【权】
//		边的权：将边赋予数值，可以表示路径长度
//		带权图/网：图的每条边上都带有权值
//		带权路径长度：一条路径上的所有边的权值之和
//
//
//
//
// (2)基本操作
//	Adjacent(G, x, y)：判断图G中是否有边<x,y>或(x,y)
//	FirstNeighbor(G, x):返回图G中x的第一个相邻的结点
//	NextNeighbor(G, x, y):y结点与x相邻，返回与x相邻的y的下一个结点
//	Neighbors(G, x)：列出图G中与顶点x相邻的所有边
//	InsertVertex(G, x)：在图G中插入顶点x
//	DeleteVertex(G, x)：从图G中删除顶点x
//	AddEdge(G, x, y)：若图G中不存在边<x,y>或(x,y)，则向图G中添加该边
//	RemoveEdge(G, x, y)：删除图G中的边<x,y>或(x,y)
//	setEdgeWeight(G, x, y, weight)：设置边<x,y>或(x,y)的权值
//	getEdgeWeight(G, x, y)：获取边<x,y>或(x,y)的权值
